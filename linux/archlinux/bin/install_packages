#!/usr/bin/env python3

import sys
import argparse
import os
import logging
import toml
import platform
import os
import subprocess

__author__ = "Shangjin Tang"
__email__ = "shangjin.tang@gmail.com"
__copyright__ = "Copyright 2023 Shangjin Tang"
__license__ = "GPL"
__version__ = "1.0.0"

ARGS = None
LOG_FORMAT = "%(asctime)s\t%(levelname)s\t%(filename)s:%(lineno)s\t%(message)s"
logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT)


BASE_LIST = ["min-base", "rec-base", "max-base"]
DEV_LIST = ["min-dev", "rec-dev", "max-dev"]
LEVELS = ["min", "rec", "max"]


class Distribution():
    @staticmethod
    def retrive_distribution():
        if platform.system() == 'Linux':
            with open("/etc/os-release") as f:
                release_info = f.read()
                if "Arch Linux" in release_info:
                    return "ArchLinux"
        return False

    @staticmethod
    def is_archlinux():
        return Distribution.retrive_distribution() == "ArchLinux"

    @staticmethod
    def try_install_packages_with_version(packages_to_install):
        if Distribution.is_archlinux() and packages_to_install:
            ArchLinux.try_install_packages_with_version(packages_to_install)

    @staticmethod
    def try_uninstall_packages(packages_to_uninstall):
        if Distribution.is_archlinux() and packages_to_uninstall:
            ArchLinux.try_uninstall_packages(packages_to_uninstall)


class ArchLinux():
    @staticmethod
    def try_install_packages_with_version(packages_to_install):
        install_commands = ['sudo', 'pacman', '-Syu', *packages_to_install, '--needed']
        print(' '.join(install_commands))
        result = subprocess.run(install_commands, stdout=subprocess.PIPE)
        result_code = result.stdout.decode()

    @staticmethod
    def try_uninstall_packages(packages_to_uninstall):
        installed_packages = ArchLinux.query_installed_packages()
        print(packages_to_uninstall)
        packages_to_uninstall = packages_to_uninstall & installed_packages
        print(packages_to_uninstall)
        uninstall_commands = ['sudo', 'pacman', '-Rs', *packages_to_uninstall]
        print(' '.join(uninstall_commands))
        # result = subprocess.run(uninstall_commands, stdout=subprocess.PIPE)
        # result_code = result.stdout.decode()
        # pass

    @staticmethod
    def query_installed_packages():
        result = subprocess.run(['pacman', '-Qq'], stdout=subprocess.PIPE)
        installed_packages = set(result.stdout.decode().strip().split('\n'))
        return installed_packages


class PackageHelper():

    def __init__(self, base_selection, dev_selection, config_file, uninstall_on_false):
        if not Distribution.is_archlinux():
            raise Exception("Only support Arch Linux")
        logging.debug("base_selection: {}".format(base_selection))
        logging.debug("dev_selection: {}".format(dev_selection))
        logging.debug("config_file: {}".format(config_file))
        logging.debug("uninstall_on_false: {}".format(uninstall_on_false))
        self.base_selection = base_selection
        self.dev_selection = dev_selection
        self.config_file = config_file
        self.uninstall_on_false = uninstall_on_false
        self.packages_to_install = dict()  # package and version(optional)
        self.packages_to_uninstall = set()  # package only


    def fetch_expanded_selections(self):
        expanded_selections = BASE_LIST[:BASE_LIST.index(self.base_selection) + 1] + DEV_LIST[:DEV_LIST.index(self.dev_selection) + 1]
        logging.debug("expanded_selections: {}".format(expanded_selections))
        return expanded_selections


    def load_toml(self):
        return toml.load(self.config_file)

    
    def fetch_package_requirements(self):
        toml_data = self.load_toml()
        package_requirements = {}
        expanded_selections = self.fetch_expanded_selections()
        for selection in expanded_selections:
            package_requirements.update(toml_data[selection])
        logging.debug("package_requirements: {}".format(package_requirements))
        self.packages_to_install = {k : v for k, v in package_requirements.items() if v != False}
        if self.uninstall_on_false:
            self.packages_to_uninstall = set(k for k, v in package_requirements.items() if v == False)
        print("Packages to install: {}".format(self.packages_to_install ))
        print("Packages to uninstall: {}".format(self.packages_to_uninstall))
        Distribution.try_install_packages_with_version(self.packages_to_install)
        Distribution.try_uninstall_packages(self.packages_to_uninstall)

def main():
    package_helper = PackageHelper(ARGS.base + "-base", ARGS.dev + "-dev", ARGS.config, ARGS.uninstall)
    package_helper.fetch_package_requirements()


def match_lists(sel):
    base = [item for item in BASE_LIST if sel in item][0]
    dev = [item for item in DEV_LIST if sel in item][0]
    return base, dev

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter, description="")
    
    if len(sys.argv[1:]) == 0:
        file_name = sys.argv[0]
        os.system("{} -b {selection} -d {selection}".format(file_name, selection=LEVELS[-1]))
    elif len(sys.argv[1:]) == 1:
        file_name, arg = sys.argv[:]
        print(arg)
        if arg in LEVELS:
            os.system("{} -b {selection} -d {selection}".format(file_name, selection=arg))
        elif arg in BASE_LIST:
            os.system("{} -b {} -d {}".format(file_name, arg.split('-')[0], LEVELS[0]))
        elif arg in DEV_LIST:
            os.system("{} -b {} -d {}".format(file_name, LEVELS[-1], arg.split('-')[0]))
        elif arg in ['-u', "--uninstall"]:
            os.system("{} -b {selection} -d {selection} -u".format(file_name, selection=LEVELS[-1]))
        else:
            logging.error("Fatal: {} is not supported, exit...".format(arg))
            exit(1)
    else:
        parser.add_argument('-b','--base', type=str, choices=LEVELS, default=LEVELS[-1], required=False)
        parser.add_argument('-d','--dev', type=str, choices=LEVELS, default=LEVELS[-1], required=False)
        parser.add_argument('-c', '--config', default="./.packagelist.toml")
        parser.add_argument('-u','--uninstall', default=False, action='store_true', help="if package value in toml is false, perform uninstall")

        ARGS = parser.parse_args()
        try:
            main()
        except KeyboardInterrupt:
            logging.info('Keyboard Interrupted')
            try:
                sys.exit(0)
            except SystemExit:
                os._exit(0)
