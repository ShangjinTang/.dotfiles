#!/usr/bin/env bash
# shellcheck disable=1091,2034,2154

# Link: https://github.com/ralish/bash-script-template
# Depends on: ./bash_source

# Enable xtrace if the DEBUG environment variable is set
if [[ ${DEBUG-} =~ ^1|yes|true$ ]]; then
    set -o xtrace # Trace the execution of the script (debug)
fi

# Only enable these shell behaviours if we're not being sourced
# Approach via: https://stackoverflow.com/a/28776166/8787985
if ! (return 0 2> /dev/null); then
    # A better class of script...
    set -o errexit  # Exit on most errors (see the manual)
    set -o nounset  # Disallow expansion of unset variables
    set -o pipefail # Use last non-zero exit code in a pipeline
fi

# Enable errtrace or the error trap handler will not work as expected
set -o errtrace # Ensure the error trap handler is inherited

# DESC: Usage help
# ARGS: None
# OUTS: None
# shellcheck disable=2046
function script_usage() {
    cat << EOF
Usage: $(basename "$0") [-a|--all] [-i|--install] [-v|--verbose]
A script to download (and install if required) binaries from github releases.

- Download dir: ~/.gh_releases/download
- Install dir: ~/.gh_releases/bin (you can add it into PATH)


Options:
     -a|--all                   Download all binaries; if not specified, only download missing binaries 
     -i|--install               Whether install after download or not

     -h|--help                  Displays this help
     -v|--verbose               Displays verbose output
    -nc|--no-colour             Disables colour output
    -cr|--cron                  Run silently unless we encounter an error

Depends on file (to be sourced in this script):
    $(realpath $(dirname "${BASH_SOURCE[0]}"))/bash_source
EOF
}

# DESC: Parameter parser
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: Variables indicating command-line parameters and options
function parse_params() {
    local param
    while [[ $# -gt 0 ]]; do
        param="$1"
        shift
        case $param in
            -h | --help)
                script_usage
                exit 0
                ;;
            -v | --verbose)
                verbose=true
                ;;
            -nc | --no-colour)
                no_colour=true
                ;;
            -cr | --cron)
                cron=true
                ;;
            -a | --all)
                download_all=true
                ;;
            -i | --install)
                install=true
                ;;
            *)
                script_exit "Invalid parameter was provided: $param" 1
                ;;
        esac
    done
}

DOWNLOAD_DIR=~/.gh_releases/download
INSTALL_DIR=~/.gh_releases/bin

function print_separate_line_wide_with_optional_arg() {
    pretty_print "============================================================" "$fg_yellow$ta_bold"
    if [ "$#" -ne 0 ]; then
        pretty_print "$*" "$fg_yellow$ta_bold"
    fi
}
function print_separate_line_with_optional_arg() {
    pretty_print "------------------------------------------------------------" "$fg_green$ta_bold"
    if [ "$#" -ne 0 ]; then
        pretty_print "$*" "$fg_green$ta_bold"
    fi
}

function binary_check() {
    local command_name="$1"
    if ! command -v "$command_name" &> /dev/null; then
        pretty_print "- $command_name does not exist" "$fg_yellow"
        return 1
    else
        pretty_print "  - [Available] " "" "-" &&
            pretty_print "$command_name" "$fg_magenta"
        return 0
    fi
}

function env_check() {
    if ! binary_check "gh"; then
        pretty_print "ERROR: 'gh' is not available, please install it and make sure it's in PATH" "$fg_red$ta_bold"
        pretty_print "See: https://github.com/cli/cli/releases/latest" "$fg_red"
        exit 1
    fi
    local ARCH
    ARCH=$(uname -m)
    if [[ $ARCH != "x86_64" ]]; then
        pretty_print "ERROR: this script does not support arch '${ARCH}'" "$fg_red $ta_bold"
        exit 1
    fi
}

function cleanup() {
    echo ""
    verbose_print "Downloading interrupted"
    if rm -f "$DOWNLOAD_DIR/$PATTERN"; then
        verbose_print "$PATTERN removed" "$fg_green"
    else
        pretty_print "$PATTERN removed error" "$fg_red"
    fi
    exit 130 # SIGINT
}

function try_download() {
    REPO="$1"
    PATTERN="$2"
    if ! find $DOWNLOAD_DIR -maxdepth 1 -type f -name "$PATTERN" -print -quit | grep -q . &> /dev/null; then
        pretty_print "- [Downloading] $PATTERN" "$fg_green"
        verbose_print "- [Executing] gh release download --dir $DOWNLOAD_DIR --repo $1 --pattern $2" "$fg_cyan"
        gh release download --dir "$DOWNLOAD_DIR" --repo "$REPO" --pattern "$PATTERN"
    else
        pretty_print "- [Exists] ~/.gh_releases/download/$PATTERN" "$fg_blue"
    fi
}

# shellcheck disable=2086
function cp_elf_executable_from_download() {
    local PATTERN=$1
    local BINARY=$2
    # shellcheck disable=2086
    verbose_print "  - [FileType] ELF"
    verbose_print "  - [Executing] cp -f $DOWNLOAD_DIR/$PATTERN $INSTALL_DIR/$BINARY" "$fg_cyan"
    cp -f $DOWNLOAD_DIR/$PATTERN $INSTALL_DIR/$BINARY
}

# shellcheck disable=2086
function extract_targz_tarxz_from_download() {
    local PATTERN=$1
    local BINARY=$2
    verbose_print "  - [FileType] .tar.gz"
    if [[ $BINARY == "lazygit" ]] || [[ $BINARY == "tokei" ]]; then
        verbose_print "  - [Executing] tar -xf $DOWNLOAD_DIR/$PATTERN --strip-components=0 --wildcards \"${BINARY}\" -C $INSTALL_DIR" "$fg_cyan"
        tar -xf $DOWNLOAD_DIR/$PATTERN --strip-components=0 --wildcards "${BINARY}" -C $INSTALL_DIR --touch
    else
        verbose_print "  - [Executing] tar -xf $DOWNLOAD_DIR/$PATTERN --strip-components=1 --wildcards \"*/${BINARY}\" -C $INSTALL_DIR" "$fg_cyan"
        tar -xf $DOWNLOAD_DIR/$PATTERN --strip-components=1 --wildcards "*/${BINARY}" -C $INSTALL_DIR --touch
    fi
}

# shellcheck disable=2086
function extract_zip_from_download() {
    local PATTERN=$1
    local BINARY=$2
    verbose_print "  - [FileType] .zip"
    if [[ $BINARY == "ast-grep" ]]; then
        rm -f $INSTALL_DIR/$BINARY &&
            unzip -j $DOWNLOAD_DIR/$PATTERN sg -d $INSTALL_DIR &> /dev/null &&
            mv $INSTALL_DIR/sg $INSTALL_DIR/$BINARY &&
            touch $INSTALL_DIR/$BINARY
    else
        unzip -j $DOWNLOAD_DIR/$PATTERN $BINARY -d $INSTALL_DIR &> /dev/null &&
            touch $INSTALL_DIR/$BINARY
    fi
}

# shellcheck disable=2086
function start_download_install_binary_with_repo() {
    local BINARY=$1
    local REPO=$2
    local PATTERN=$3
    local install_flag=false
    if [[ -n ${download_all-} ]] || ! binary_check "$BINARY"; then
        print_separate_line_with_optional_arg "$BINARY"
        try_download "$REPO" "$PATTERN"
        if [[ -n ${install-} ]]; then
            if [[ ! -f $INSTALL_DIR/$BINARY ]] || [[ $DOWNLOAD_DIR/$PATTERN -nt $INSTALL_DIR/$BINARY ]]; then
                if [[ $PATTERN == *.tar.gz ]] || [[ $PATTERN == *.tar.xz ]]; then
                    extract_targz_tarxz_from_download "$PATTERN" "$BINARY"
                    install_done_flag=true
                elif [[ $PATTERN == *.zip ]]; then
                    extract_zip_from_download "$PATTERN" "$BINARY"
                    install_done_flag=true
                elif file $DOWNLOAD_DIR/$PATTERN | grep "ELF" &> /dev/null; then
                    cp_elf_executable_from_download "$PATTERN" "$BINARY"
                    install_done_flag=true
                else
                    pretty_print "  - [FileType] UNRECOGNIZED" "$fg_red"
                    install_done_flag=false
                    exit 1
                fi
                if $install_done_flag; then
                    chmod 0755 "$INSTALL_DIR/$BINARY" && pretty_print "- [Install] OK"
                fi
            else
                pretty_print "- [Exists] ~/.gh_releases/bin/$BINARY is newer" "$fg_blue"
            fi
        fi
    fi
}

# DESC: Main control flow
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: None
function main() {
    trap script_trap_err ERR
    trap script_trap_exit EXIT
    trap cleanup SIGINT

    script_init "$@"
    parse_params "$@"
    cron_init
    colour_init
    #lock_init system

    # check environment
    print_separate_line_wide_with_optional_arg "ENV CHECK"
    env_check
    # prepare directories
    [[ ! -d $DOWNLOAD_DIR ]] && mkdir -p $DOWNLOAD_DIR
    [[ ! -d $INSTALL_DIR ]] && mkdir -p $INSTALL_DIR

    if [[ -n ${install-} ]]; then
        print_separate_line_wide_with_optional_arg "Download & Install"
        cd $INSTALL_DIR
    else
        print_separate_line_wide_with_optional_arg "Download"
    fi

    # nvim: https://github.com/neovim/neovim/releases/download
    start_download_install_binary_with_repo "nvim" "neovim/neovim" "nvim.appimage"

    # ast-grep: https://github.com/ast-grep/ast-grep/releases/latest
    start_download_install_binary_with_repo "ast-grep" "ast-grep/ast-grep" "sg-x86_64-unknown-linux-gnu.zip"

    # bat: https://github.com/sharkdp/bat/releases/latest
    start_download_install_binary_with_repo "bat" "sharkdp/bat" "bat-*-x86_64-unknown-linux-musl.tar.gz"

    # delta: https://github.com/dandavison/delta/releases/latest
    start_download_install_binary_with_repo "delta" "dandavison/delta" "delta-*-x86_64-unknown-linux-musl.tar.gz"

    # dua: https://github.com/Byron/dua-cli/releases/latest
    start_download_install_binary_with_repo "dua" "Byron/dua-cli" "dua-*-x86_64-unknown-linux-musl.tar.gz"

    # dust: https://github.com/bootandy/dust/releases/latest
    start_download_install_binary_with_repo "dust" "bootandy/dust" "dust-*-x86_64-unknown-linux-musl.tar.gz"

    # fd: https://github.com/sharkdp/fd/releases/latest
    start_download_install_binary_with_repo "fd" "sharkdp/fd" "fd-*-x86_64-unknown-linux-musl.tar.gz"

    # hexyl: https://github.com/sharkdp/hexyl/releases/latest
    start_download_install_binary_with_repo "hexyl" "sharkdp/hexyl" "hexyl-*-x86_64-unknown-linux-musl.tar.gz"

    # hyperfine: https://github.com/sharkdp/hyperfine/releases/latest
    start_download_install_binary_with_repo "hyperfine" "sharkdp/hyperfine" "hyperfine-*-x86_64-unknown-linux-musl.tar.gz"

    # lazygit: https://github.com/jesseduffield/lazygit/releases/latest
    start_download_install_binary_with_repo "lazygit" "jesseduffield/lazygit" "lazygit_0.40.2_Linux_x86_64.tar.gz"

    # lsd: https://github.com/lsd-rs/lsd/releases/latest
    start_download_install_binary_with_repo "lsd" "lsd-rs/lsd" "lsd-*-x86_64-unknown-linux-musl.tar.gz"

    # macchina: https://github.com/Macchina-CLI/macchina/releases/latest
    start_download_install_binary_with_repo "macchina" "Macchina-CLI/macchina" "macchina-linux-x86_64"

    # ouch: https://github.com/ouch-org/ouch/releases/latest
    start_download_install_binary_with_repo "ouch" "ouch-org/ouch" "ouch-x86_64-unknown-linux-musl.tar.gz"

    # procs: https://github.com/dalance/procs/releases/latest
    start_download_install_binary_with_repo "procs" "dalance/procs" "procs-*-x86_64-linux.zip"

    # pueue & pueued: https://github.com/Nukesor/pueue/releases/latest
    start_download_install_binary_with_repo "pueue" "Nukesor/pueue" "pueue-linux-x86_64"
    start_download_install_binary_with_repo "pueued" "Nukesor/pueue" "pueued-linux-x86_64"

    # rg: https://github.com/BurntSushi/ripgrep/releases/latest
    start_download_install_binary_with_repo "rg" "BurntSushi/ripgrep" "ripgrep-*-x86_64-unknown-linux-musl.tar.gz"

    # sd: https://github.com/chmln/sd/releases/latest
    start_download_install_binary_with_repo "sd" "chmln/sd" "sd-*-x86_64-unknown-linux-musl"

    # tldr: https://github.com/dbrgn/tealdeer/releases/latest
    start_download_install_binary_with_repo "tldr" "dbrgn/tealdeer" "tealdeer-linux-x86_64-musl"

    # tokei: https://github.com/XAMPPRocky/tokei/releases/latest
    start_download_install_binary_with_repo "tokei" "XAMPPRocky/tokei" "tokei-x86_64-unknown-linux-gnu.tar.gz"

    # tokei: https://github.com/watchexec/watchexec/releases/latest
    start_download_install_binary_with_repo "watchexec" "watchexec/watchexec" "watchexec-*-x86_64-unknown-linux-musl.tar.xz"
}

# shellcheck source=source.sh
source "$(dirname "${BASH_SOURCE[0]}")/bash_source"

# Invoke main with args if not sourced
# Approach via: https://stackoverflow.com/a/28776166/8787985
if ! (return 0 2> /dev/null); then
    main "$@"
fi

# vim: syntax=sh cc=120 tw=119 ts=4 sw=4 sts=4 et sr
